"use strict";(globalThis.webpackChunkdsa_notes=globalThis.webpackChunkdsa_notes||[]).push([[256],{1725(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"two-pointers/overview","title":"Two Pointers Overview","description":"The Two Pointers technique uses two pointers to traverse a data structure (usually an array or string) efficiently, often reducing time complexity from O(n\xb2) to O(n).","source":"@site/docs/two-pointers/overview.md","sourceDirName":"two-pointers","slug":"/two-pointers/overview","permalink":"/docs/two-pointers/overview","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Arrays & Hashmaps","permalink":"/docs/arrays-hashmap/"},"next":{"title":"Common Patterns","permalink":"/docs/two-pointers/patterns"}}');var s=t(4848),o=t(8453);const i={sidebar_position:1},a="Two Pointers Overview",d={},c=[{value:"When to Use",id:"when-to-use",level:2},{value:"Core Idea",id:"core-idea",level:2}];function l(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"two-pointers-overview",children:"Two Pointers Overview"})}),"\n",(0,s.jsx)(n.p,{children:"The Two Pointers technique uses two pointers to traverse a data structure (usually an array or string) efficiently, often reducing time complexity from O(n\xb2) to O(n)."}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sorted arrays"}),": Finding pairs, triplets, or subarrays that meet certain conditions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strings"}),": Palindrome checking, substring problems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Linked lists"}),": Finding middle, detecting cycles, merging lists"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimization problems"}),": When brute force would be O(n\xb2) or worse"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"core-idea",children:"Core Idea"}),"\n",(0,s.jsx)(n.p,{children:"Instead of nested loops, use two pointers that move based on the problem's constraints. The pointers can:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Start at opposite ends and move toward each other"}),"\n",(0,s.jsx)(n.li,{children:"Start at the same end and move in the same direction"}),"\n",(0,s.jsx)(n.li,{children:"Move at different speeds"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The key is identifying when and how to move each pointer based on the current values they point to."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453(e,n,t){t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);